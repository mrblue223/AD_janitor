import streamlit as st
import pandas as pd
import plotly.express as px
import io

# --- CONFIGURATION ---
st.set_page_config(
    page_title="Active Directory Security Dashboard",
    page_icon="üõ°Ô∏è",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- HELPER FUNCTIONS ---

@st.cache_data
def load_data(uploaded_file):
    """Loads and processes the uploaded CSV data."""
    if uploaded_file.name.endswith('.csv'):
        # Read the CSV file into a Pandas DataFrame
        df = pd.read_csv(uploaded_file)
        
        # Standardize column names (adjust these based on your AD_janitor output)
        df.columns = [col.strip().replace(' ', '_') for col in df.columns]

        # Ensure required columns exist, or create placeholders
        required_cols = ['User_Name', 'Vulnerability_Type', 'Risk_Level', 'Description']
        for col in required_cols:
            if col not in df.columns:
                st.error(f"Missing required column: '{col}'. Please ensure your report includes this column.")
                return pd.DataFrame(), False # Return empty data and fail flag
        
        # Categorize Risk_Level for consistent visualization
        risk_order = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW', 'INFORMATIONAL']
        df['Risk_Level'] = pd.Categorical(df['Risk_Level'].str.upper(), categories=risk_order, ordered=True)

        return df, True # Return processed data and success flag
    
    else:
        st.error("Unsupported file format. Please upload a CSV file.")
        return pd.DataFrame(), False


# --- STREAMLIT DASHBOARD LAYOUT ---

def main_dashboard():
    st.title("üõ°Ô∏è Active Directory Security Audit Dashboard")
    st.markdown("A professional visualization tool for findings generated by **AD_janitor.py**.")

    # Sidebar for File Upload
    with st.sidebar:
        st.header("1. Upload Report")
        uploaded_file = st.file_uploader(
            "Upload the Vulnerability Report (CSV)", 
            type=['csv'],
            help="Your AD_janitor.py script must output a CSV file with User Name, Vulnerability Type, Risk Level, and Description."
        )
        st.markdown("---")
        st.header("2. Risk Score")
        # Global risk score input
        global_risk_score = st.number_input(
            'Overall Risk Score (0-100)',
            min_value=0, 
            max_value=100, 
            value=st.session_state.get('risk_score', 0),
            step=1,
            help="Enter the overall Risk Score calculated by AD_janitor.py."
        )
        st.session_state['risk_score'] = global_risk_score
        
        # Display Risk Level based on score
        if global_risk_score >= 75:
            risk_level = "CRITICAL"
            st.error(f"Current Risk Level: {risk_level}")
        elif global_risk_score >= 50:
            risk_level = "HIGH"
            st.warning(f"Current Risk Level: {risk_level}")
        elif global_risk_score >= 25:
            risk_level = "MEDIUM"
            st.info(f"Current Risk Level: {risk_level}")
        else:
            risk_level = "LOW"
            st.success(f"Current Risk Level: {risk_level}")

    # --- MAIN CONTENT ---
    if uploaded_file is None:
        st.info("Upload an AD Janitor CSV report to begin analysis.")
        return

    # Load and process data
    df, success = load_data(uploaded_file)

    if not success or df.empty:
        return

    # --- 1. KEY METRICS ---
    st.subheader("Executive Summary & Key Metrics")
    col1, col2, col3, col4 = st.columns(4)

    # Calculate metrics
    total_users = df['User_Name'].nunique()
    total_vulnerabilities = len(df)
    unique_vulnerabilities = df['Vulnerability_Type'].nunique()
    critical_findings = len(df[df['Risk_Level'] == 'CRITICAL'])

    col1.metric("Total Unique Users with Findings", f"{total_users:,}")
    col2.metric("Total Findings Recorded", f"{total_vulnerabilities:,}")
    col3.metric("Unique Vulnerability Types", f"{unique_vulnerabilities}")
    col4.metric("CRITICAL Findings", f"{critical_findings:,}")
    st.markdown("---")
    
    # 

    # --- 2. VULNERABILITY DISTRIBUTION CHARTS ---
    st.subheader("Vulnerability Distribution Analysis")
    chart_col1, chart_col2 = st.columns(2)

    # Chart 1: Findings by Risk Level (Pie Chart)
    with chart_col1:
        risk_counts = df['Risk_Level'].value_counts().reset_index()
        risk_counts.columns = ['Risk_Level', 'Count']
        
        # Define color scheme for professional look
        color_map = {
            'CRITICAL': '#e31a1c',
            'HIGH': '#ff7f00',
            'MEDIUM': '#fdbf6f',
            'LOW': '#b2df8a',
            'INFORMATIONAL': '#a6cee3'
        }
        
        fig_risk = px.pie(
            risk_counts, 
            values='Count', 
            names='Risk_Level', 
            title='Findings Distribution by Risk Level',
            color='Risk_Level',
            color_discrete_map=color_map,
            hole=.3
        )
        fig_risk.update_traces(textposition='inside', textinfo='percent+label')
        st.plotly_chart(fig_risk, use_container_width=True)

    # Chart 2: Top Vulnerability Types (Bar Chart)
    with chart_col2:
        vuln_type_counts = df['Vulnerability_Type'].value_counts().reset_index()
        vuln_type_counts.columns = ['Vulnerability_Type', 'Count']
        
        fig_vuln = px.bar(
            vuln_type_counts.head(10), 
            x='Vulnerability_Type', 
            y='Count', 
            title='Top 10 Most Frequent Vulnerability Types',
            color='Vulnerability_Type',
            template='plotly_white'
        )
        fig_vuln.update_xaxes(tickangle=45)
        st.plotly_chart(fig_vuln, use_container_width=True)

    st.markdown("---")

    # --- 3. DETAILED FILTERABLE FINDINGS ---
    st.subheader("Detailed Vulnerability Findings")

    # Add filters for the table
    col_filters, col_download = st.columns([3, 1])

    with col_filters:
        selected_risk = st.multiselect(
            "Filter by Risk Level",
            options=df['Risk_Level'].cat.categories.tolist(),
            default=['CRITICAL', 'HIGH']
        )
        
        selected_vuln = st.selectbox(
            "Filter by Vulnerability Type",
            options=['All'] + df['Vulnerability_Type'].unique().tolist()
        )

    # Apply filters
    filtered_df = df[df['Risk_Level'].isin(selected_risk)]
    if selected_vuln != 'All':
        filtered_df = filtered_df[filtered_df['Vulnerability_Type'] == selected_vuln]

    # Display the filtered table
    st.dataframe(
        filtered_df[['User_Name', 'Vulnerability_Type', 'Risk_Level', 'Description']].sort_values(by='Risk_Level', ascending=True),
        use_container_width=True,
        hide_index=True
    )

    # Download filtered data button
    with col_download:
        @st.cache_data
        def convert_df_to_csv(df):
            return df.to_csv(index=False).encode('utf-8')

        csv_data = convert_df_to_csv(filtered_df)
        st.download_button(
            label="‚¨áÔ∏è Download Filtered Data as CSV",
            data=csv_data,
            file_name='ad_janitor_filtered_report.csv',
            mime='text/csv',
            key='download_csv'
        )

if __name__ == '__main__':
    main_dashboard()